# -*- coding: utf-8 -*-
"""Opt_AI_Term_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WtaxJeLu4jE_TOOqtftggqhUAsf8DQRB

# Implementation of Objective Function

## Implementation(Definitions Only)
"""

import numpy as np
from scipy.integrate import quad

# Constants
e = np.e

# Parameters - [Unverified]
a_1 = 30
a_2 = 100
b_1 = 5.0
b_2 = np.log(2)/8
D_0 = 50
beta_1 = 0.5
beta_2 = 0.5
beta_3 = 0.5
c = 20.0
K = 500.0

# Parameters - [Verified]
alpha_1 = 1.0
alpha_2 = 1.0
alpha_3 = 1.0
gamma_1 = 0.4
gamma_2 = 0.4
gamma_3 = 0.3
delta_1 = 0.25
delta_2 = 0.3
delta_3 = 0.3
mu_1 = 4.0
mu_2 = 8.0
theta_0 = 0.2
theta_1 = 0.4
xi = 0.05
theta = lambda u: theta_0 + (theta_1 - theta_0)*e**(-xi*u)
S_0 = 50.0
h = 0.5
c_d = 5.0

# Control variables - [Verified]
def lambda_1(t, static_variables):
    p_1, p_2, p_3, u, T = static_variables
    if t>=0 and t<mu_1:
        first_term = gamma_1*(p_1 + (h + theta(u)*c_d)/theta(u))*((1 - e**(-delta_1*(mu_1 - t)))/delta_1)
        second_term = gamma_1*(h + theta(u)*c_d)*e**(theta(u)*t)/(theta(u)*(theta(u) - delta_1))*(1 - e**((theta(u) - delta_1)*(mu_1 - t)))
        third_term = lambda_1(mu_1, static_variables)*e**(-delta_1*(mu_1 - t))
    elif t>=mu_1 and t<mu_2:
        first_term = gamma_2*(p_2 + (h + theta(u)*c_d)/theta(u))*((1 - e**(-delta_2*(mu_2 - t)))/delta_2)
        second_term = gamma_2*(h + theta(u)*c_d)*e**(theta(u)*t)/(theta(u)*(theta(u) - delta_2))*(1 - e**((theta(u) - delta_2)*(mu_2 - t)))
        third_term = lambda_1(mu_2, static_variables)*e**(-delta_2*(mu_2 - t))
    elif t>=mu_2: # and t<T: simplified for numerical stability
        first_term = gamma_3*(p_3 + (h + theta(u)*c_d)/theta(u))*((1 - e**(-delta_3*(T - t)))/delta_3)
        second_term = gamma_3*(h + theta(u)*c_d)*e**(theta(u)*t)/(theta(u)*(theta(u) - delta_3))*(1 - e**((theta(u) - delta_3)*(T - t)))
        third_term = 0
    return first_term + second_term + third_term

def s_1(t, static_variables):
    return lambda_1(t, static_variables)/(2*alpha_1)

def s_2(t, static_variables):
    return lambda_1(t, static_variables)/(2*alpha_2)

def s_3(t, static_variables):
    return lambda_1(t, static_variables)/(2*alpha_3)

# Omegas - [Verified]
omega_1 = lambda u: (h + theta(u)*c_d)/theta(u)
omega_2 = lambda t: (e**(delta_1*t) - e**(-delta_1*t))/(2*delta_1)
omega_9 = lambda t: (e**(delta_2*t) - e**(2*delta_2*mu_1 - delta_2*t))/(2*delta_2)
omega_10 = lambda t: (e**(delta_3*t) - e**(2*delta_3*mu_2 - delta_3*t))/(2*delta_3)

# Omegas - [Unverified]
omega_3 = lambda t, u: (e**(-delta_1*t) - e**(-theta(u)*t))/(theta(u) - delta_1)
omega_4 = lambda t, u: (e**(delta_1*t) - e**(-theta(u)*t))/(theta(u) + delta_1)
omega_5 = lambda t, u: (e**(-delta_2*t) - e**((theta(u) - delta_2)*mu_1 - theta(u)*t))/(theta(u) - delta_2)
omega_6 = lambda t, u: (e**(delta_2*t) - e**((theta(u) + delta_2)*mu_1 - theta(u)*t))/(theta(u) + delta_2)
omega_7 = lambda t, u: (e**(-delta_3*t) - e**((theta(u) - delta_3)*mu_2 - theta(u)*t))/(theta(u) - delta_3)
omega_8 = lambda t, u: (e**(delta_3*t) - e**((theta(u) + delta_3)*mu_2 - theta(u)*t))/(theta(u) + delta_3)
omega_11 = lambda t, u: omega_4(t, u) - omega_3(t, u)
omega_12 = lambda t, u: omega_6(t, u) - e**(2*delta_2*mu_1)*omega_5(t, u)
omega_13 = lambda t, u: omega_8(t, u) - e**(2*delta_3*mu_2)*omega_7(t, u)

# State variables - [Verified]
def S(t, static_variables):
    p_1, p_2, p_3, u, T = static_variables
    if t>=0 and t<=mu_1:
        first_term = gamma_1*(p_1 + omega_1(u))*((1 - e**(-delta_1*t))/delta_1 - e**(-delta_1*mu_1)*omega_2(t))/(2*alpha_1*delta_1)
        second_term = gamma_1*omega_1(u)*((e**(theta(u)*t) - e**(-delta_1*t))/(theta(u) + delta_1) - e**((theta(u) - delta_1)*mu_1)*omega_2(t))/(2*alpha_1*(theta(u) - delta_1))
        third_term = lambda_1(mu_1, static_variables)*e**(-delta_1*mu_1)*omega_2(t)/(2*alpha_1)
        fourth_term = S_0*e**(-delta_1*t)
    elif t>mu_1 and t<=mu_2:
        first_term = gamma_2*(p_2 + omega_1(u))*((1 - e**(delta_2*(mu_1 - t)))/delta_2 - e**(-delta_2*mu_2)*omega_9(t))/(2*alpha_2*delta_2)
        second_term = gamma_2*omega_1(u)*((e**(theta(u)*t) - e**((theta(u) + delta_2)*mu_1 - delta_2*t))/(theta(u) + delta_2) - e**((theta(u) - delta_2)*mu_2)*omega_9(t))/(2*alpha_2*(theta(u) - delta_2))
        third_term = lambda_1(mu_2, static_variables)*e**(-delta_2*mu_2)*omega_9(t)/(2*alpha_2)
        fourth_term = S(mu_1, static_variables)*e**(-delta_2*(t - mu_1))
    elif t>mu_2: # and t<T: simplified for numerical stability
        first_term = gamma_3*(p_3 + omega_1(u))*((1 - e**(delta_3*(mu_2 - t)))/delta_3 - e**(-delta_3*T)*omega_10(t))/(2*alpha_3*delta_3)
        second_term = gamma_3*omega_1(u)*((e**(theta(u)*t) - e**((theta(u) + delta_3)*mu_2 - delta_3*t))/(theta(u) + delta_3) - e**((theta(u) - delta_3)*T)*omega_10(t))/(2*alpha_3*(theta(u) - delta_3))
        third_term = 0
        fourth_term = S(mu_2, static_variables)*e**(-delta_3*(t - mu_2))
    return first_term + second_term + third_term + fourth_term

# Dependent variables - [Unverified]
def I_0(static_variables):
    p_1, p_2, p_3, u, T = static_variables
    t = mu_1
    second_term = -(a_1 - beta_1*p_1)*(1 - e**(-theta(u)*t))/theta(u)
    third_term = -b_1*(t/theta(u) - (1 - e**(-theta(u)*t))/theta(u)**2)
    fourth_term = gamma_1*S(0, static_variables)*omega_3(t, u)
    fifth_term_1 = lambda_1(mu_1, static_variables)*e**(-delta_1*mu_1)*omega_11(t, u)/(2*delta_1)
    fifth_term_2 = gamma_1*(p_1 + omega_1(u))/delta_1*(1/delta_1*((1 - e**(-theta(u)*t))/theta(u) - omega_3(t, u)) - (e**(-delta_1*mu_1)*omega_11(t, u))/(2*delta_1))
    fifth_term_3 = gamma_1*omega_1(u)/(theta(u) - delta_1)*(1/(theta(u) + delta_1)*((e**(theta(u)*t) - e**(-theta(u)*t))/(2*theta(u)) - omega_3(t, u)) - (e**((theta(u) - delta_1)*mu_1)*omega_11(t, u))/(2*delta_1))
    fifth_term = -gamma_1/(2*alpha_1)*(fifth_term_1 + fifth_term_2 + fifth_term_3)
    return (I_mu_1(static_variables) - second_term - third_term - fourth_term - fifth_term)/(e**(-theta(u)*t)) 

def I_mu_1(static_variables):
    p_1, p_2, p_3, u, T = static_variables
    t = mu_2
    second_term = -(D_0 - beta_2*p_2)*(1 - e**(-theta(u)*(t - mu_1)))/theta(u)
    third_term = -gamma_2*S(mu_1, static_variables)*e**(delta_2*mu_1)*omega_5(t, u)
    fourth_term_1 = gamma_2*(p_2 + omega_1(u))/delta_2*(1/delta_2*((1 - e**(theta(u)*(mu_1 - t)))/theta(u) - e**(delta_2*mu_1)*omega_5(t, u)) - (e**(-delta_2*mu_2)*omega_12(t, u))/(2*delta_2))
    fourth_term_2 = gamma_2*omega_1(u)/(theta(u) - delta_2)*((e**(theta(u)*t) - e**(2*theta(u)*mu_1 - theta(u)*t))/(2*theta(u)*(theta(u) + delta_2)) - (e**((theta(u) + delta_2)*mu_1)*omega_5(t, u))/(theta(u) + delta_2) - (e**((theta(u) - delta_2)*mu_2)*omega_12(t, u))/(2*delta_2))
    fourth_term_3 = lambda_1(mu_2, static_variables)*e**(-delta_2*mu_2)*omega_12(t, u)/(2*delta_2)
    fourth_term = -gamma_2/(2*alpha_2)*(fourth_term_1 + fourth_term_2 + fourth_term_3)
    return (I_mu_2(static_variables) - second_term - third_term - fourth_term)/(e**(-theta(u)*(t - mu_1)))

def I_mu_2(static_variables):
    p_1, p_2, p_3, u, T = static_variables
    t = T
    second_term = beta_3*p_3*(1 - e**(-theta(u)*(t - mu_2)))/theta(u)
    third_term = -a_2*(e**(-b_2*t) - e**((theta(u) - b_2)*mu_2 - theta(u)*t))/(theta(u) - b_2)
    fourth_term = -gamma_3*S(mu_2, static_variables)*e**(delta_3*mu_2)*omega_7(t, u)
    fifth_term_1 = gamma_3*(p_3 + omega_1(u))/delta_3*((1 - e**(theta(u)*(mu_2 - t)))/(theta(u)*delta_3) - (e**(delta_3*mu_2)*omega_7(t, u))/delta_3 - (e**(-delta_3*T)*omega_13(t, u))/(2*delta_3))
    fifth_term_2 = gamma_3*omega_1(u)/(theta(u) - delta_3)*((e**(theta(u)*t) - e**(2*theta(u)*mu_2 - theta(u)*t))/(2*theta(u)*(theta(u) + delta_3)) - (e**((theta(u) + delta_3)*mu_2)*omega_7(t, u))/(theta(u) + delta_3) - (e**((theta(u) - delta_3)*T)*omega_13(t, u))/(2*delta_3))
    fifth_term_3 = lambda_1(T, static_variables)*e**(-delta_3*T)*omega_13(t, u)/(2*delta_3)
    fifth_term = -gamma_3/(2*alpha_3)*(fifth_term_1 + fifth_term_2 + fifth_term_3)
    return -(second_term + third_term + fourth_term + fifth_term)/(e**(-theta(u)*(t - mu_2)))

# State variables - [Unverified]
def I(t, static_variables):
    p_1, p_2, p_3, u, T = static_variables
    if t>=0 and t<=mu_1:
        first_term = I_0(static_variables)*e**(-theta(u)*t)
        second_term = -(a_1 - beta_1*p_1)*(1 - e**(-theta(u)*t))/theta(u)
        third_term = -b_1*(t/theta(u) - (1 - e**(-theta(u)*t))/theta(u)**2)
        fourth_term = gamma_1*S(0, static_variables)*omega_3(t, u)
        fifth_term_1 = lambda_1(mu_1, static_variables)*e**(-delta_1*mu_1)*omega_11(t, u)/(2*delta_1)
        fifth_term_2 = gamma_1*(p_1 + omega_1(u))/delta_1*(1/delta_1*((1 - e**(-theta(u)*t))/theta(u) - omega_3(t, u)) - (e**(-delta_1*mu_1)*omega_11(t, u))/(2*delta_1))
        fifth_term_3 = gamma_1*omega_1(u)/(theta(u) - delta_1)*(1/(theta(u) + delta_1)*((e**(theta(u)*t) - e**(-theta(u)*t))/(2*theta(u)) - omega_3(t, u)) - (e**((theta(u) - delta_1)*mu_1)*omega_11(t, u))/(2*delta_1))
        fifth_term = -gamma_1/(2*alpha_1)*(fifth_term_1 + fifth_term_2 + fifth_term_3)
    elif t>mu_1 and t<=mu_2:
        first_term = I_mu_1(static_variables)*e**(-theta(u)*(t - mu_1))
        second_term = -(D_0 - beta_2*p_2)*(1 - e**(-theta(u)*(t - mu_1)))/theta(u)
        third_term = -gamma_2*S(mu_1, static_variables)*e**(delta_2*mu_1)*omega_5(t, u)
        fourth_term_1 = gamma_2*(p_2 + omega_1(u))/delta_2*(1/delta_2*((1 - e**(theta(u)*(mu_1 - t)))/theta(u) - e**(delta_2*mu_1)*omega_5(t, u)) - (e**(-delta_2*mu_2)*omega_12(t, u))/(2*delta_2))
        fourth_term_2 = gamma_2*omega_1(u)/(theta(u) - delta_2)*((e**(theta(u)*t) - e**(2*theta(u)*mu_1 - theta(u)*t))/(2*theta(u)*(theta(u) + delta_2)) - (e**((theta(u) + delta_2)*mu_1)*omega_5(t, u))/(theta(u) + delta_2) - (e**((theta(u) - delta_2)*mu_2)*omega_12(t, u))/(2*delta_2))
        fourth_term_3 = lambda_1(mu_2, static_variables)*e**(-delta_2*mu_2)*omega_12(t, u)/(2*delta_2)
        fourth_term = -gamma_2/(2*alpha_2)*(fourth_term_1 + fourth_term_2 + fourth_term_3)
        fifth_term = 0
    elif t>mu_2: # and t<T: simplified for numerical stability
        first_term = I_mu_2(static_variables)*e**(-theta(u)*(t - mu_2))
        second_term = beta_3*p_3*(1 - e**(-theta(u)*(t - mu_2)))/theta(u)
        third_term = -a_2*(e**(-b_2*t) - e**((theta(u) - b_2)*mu_2 - theta(u)*t))/(theta(u) - b_2)
        fourth_term = -gamma_3*S(mu_2, static_variables)*e**(delta_3*mu_2)*omega_7(t, u)
        fifth_term_1 = gamma_3*(p_3 + omega_1(u))/delta_3*((1 - e**(theta(u)*(mu_2 - t)))/(theta(u)*delta_3) - (e**(delta_3*mu_2)*omega_7(t, u))/delta_3 - (e**(-delta_3*T)*omega_13(t, u))/(2*delta_3))
        fifth_term_2 = gamma_3*omega_1(u)/(theta(u) - delta_3)*((e**(theta(u)*t) - e**(2*theta(u)*mu_2 - theta(u)*t))/(2*theta(u)*(theta(u) + delta_3)) - (e**((theta(u) + delta_3)*mu_2)*omega_7(t, u))/(theta(u) + delta_3) - (e**((theta(u) - delta_3)*T)*omega_13(t, u))/(2*delta_3))
        fifth_term_3 = lambda_1(T, static_variables)*e**(-delta_3*T)*omega_13(t, u)/(2*delta_3)
        fifth_term = -gamma_3/(2*alpha_3)*(fifth_term_1 + fifth_term_2 + fifth_term_3)
    return first_term + second_term + third_term + fourth_term + fifth_term

# Object variable - [Unverified]
def Pi(static_variables):
    p_1, p_2, p_3, u, T = static_variables
    integrand_1 = lambda t: gamma_1*p_1*S(t, static_variables) - (h + theta(u)*c_d)*I(t, static_variables) - alpha_1*s_1(t, static_variables)**2/2
    integrand_2 = lambda t: gamma_2*p_2*S(t, static_variables) - (h + theta(u)*c_d)*I(t, static_variables) - alpha_2*s_2(t, static_variables)**2/2
    integrand_3 = lambda t: gamma_3*p_3*S(t, static_variables) - (h + theta(u)*c_d)*I(t, static_variables) - alpha_3*s_3(t, static_variables)**2/2
    integral_terms = quad(integrand_1, 0, mu_1)[0] + quad(integrand_2, mu_1, mu_2)[0] + quad(integrand_3, mu_2, T)[0]
    non_integral_terms = p_1*((a_1 - beta_1*p_1)*mu_1 + b_1*mu_1**2/2) + p_3*(a_2*(e**(-b_2*mu_2) - e**(-b_2*T))/b_2 - beta_3*p_3*(T - mu_2)) + p_2*(mu_2 - mu_1)*(D_0 - beta_2*p_2) - (K + c*I_0(static_variables) + u)
    return (non_integral_terms + integral_terms)/T

# Constraints - [Unverified]
def penalty(static_variables):
    p_1, p_2, p_3, u, T = static_variables
    constraints = []
    constraints.append(lambda: -(a_1 - beta_1*p_1 + gamma_1*S(0, static_variables)))
    constraints.append(lambda: -(D_0 - beta_2*p_2 + gamma_2*S(mu_1, static_variables)))
    constraints.append(lambda: -(a_2*e**(-b_2*mu_2) - beta_3*p_2 + gamma_3*S(mu_2, static_variables)))
    Gamma_1 = lambda: ((h + c_d*theta(u))*(e**(delta_3*mu_2)*(theta(u) - delta_3*(1 - e**(T*theta(u))))) - e**(delta_3*T)*(theta(u) - delta_3*(1 - e**(theta(u)*mu_2))))/((e**(delta_3*T) - e**(delta_3*mu_2))*theta(u)*(theta(u) - delta_3))
    constraints.append(lambda: -(p_1 - c))
    constraints.append(lambda: -(p_2 - c))
    constraints.append(lambda: -(p_3 - max(c, Gamma_1())))
    constraints.append(lambda: -(T - mu_2))
    psi = 10**6
    return sum([psi*max(0, constraint()) for constraint in constraints])

# Final objective function - [Unverified]
def F(static_variables):
    try:
        return -Pi(static_variables) + penalty(static_variables)
    except ZeroDivisionError:
        return 10**6
# F = lambda static_variables: -Pi(static_variables) + penalty(static_variables)

"""## Validation"""

# Validation for s_i and S - [Verified]
import random

# Static variables
p_1 = 81.11
p_2 = 96.32
p_3 = 81.78
u = 87.21
T = 8.85
solution = [p_1, p_2, p_3, u, T]

validation_s_1 = lambda t: 70.8628 - 31.4823*e**(0.202554*t) + 14.2673*e**(0.25*t)
validation_s_2 = lambda t: 69.1923 - 15.3285*e**(0.202554*t) + 1.24483*e**(0.3*t)
validation_s_3 = lambda t: 44.6242 - 11.4964*e**(0.202554*t) + 1.71617*e**(0.3*t)
validation_S_1 = lambda t: 283.451 - 192.42*e**(-0.25*t) - 69.5652*e**(0.202554*t) + 28.5342*e**(0.25*t)
validation_S_2 = lambda t: 230.641 - 116.646*e**(-0.3*t) - 30.5011*e**(0.202554*t) + 2.07465*e**(0.3*t)
validation_S_3 = lambda t: 148.747 + 265.706*e**(-0.3*t) - 22.8758*e**(0.202554*t) + 2.86022*e**(0.3*t)

t = random.uniform(0, mu_1)
print(f'For t = {t}')
print(f's_1(t) diff: {validation_s_1(t) - s_1(t, solution)}')
print(f'S(t) diff:{validation_S_1(t) - S(t, solution)}\n')
t = random.uniform(mu_1, mu_2)
print(f'For t = {t}')
print(f's_2(t) diff: {validation_s_2(t) - s_2(t, solution)}')
print(f'S(t) diff:{validation_S_2(t) - S(t, solution)}\n')
t = random.uniform(mu_2, T)
print(f'For t = {t}')
print(f's_3(t) diff: {validation_s_3(t) - s_3(t, solution)}')
print(f'S(t) diff:{validation_S_3(t) - S(t, solution)}')

# Validation for I(0|mu_1|mu_2) and Pi - [Unverified]

# Static variables
p_1 = 81.11
p_2 = 96.32
p_3 = 81.78
u = 87.21
T = 8.85
solution = [p_1, p_2, p_3, u, T]

print('Expected I_0: 448.52')
print(f'Implemented I_0({solution}): {I_0(solution)}')
print(f'Implemented I_mu_1({solution}): {I_mu_1(solution)}')
print(f'Implemented I_mu_2({solution}): {I_mu_2(solution)}\n')

print('Expected Pi: 1348.82')
print(f'Implemented Pi({solution}): {Pi(solution)}')

"""# Solving the Optimization Problem

## Implemented PSO
"""

# https://nathanrooy.github.io/posts/2016-08-17/simple-particle-swarm-optimization-with-python/

#------------------------------------------------------------------------------+
#
#   Originally by:
#       Nathan A. Rooy
#       Simple Particle Swarm Optimization (PSO) with Python
#       July, 2016
#
#   Modified by:
#       Jinyoung, Sung
#       May, 2021
#
#------------------------------------------------------------------------------+

#--- IMPORT DEPENDENCIES ------------------------------------------------------+

import random
import math


#--- MAIN ---------------------------------------------------------------------+

class Particle:
    def __init__(self, x0):
        self.position_i = []          # particle position
        self.velocity_i = []          # particle velocity
        self.pos_best_i = []          # best position individual
        self.err_best_i = -1          # best error individual
        self.err_i = -1               # error individual

        for i in range(num_dimensions):
            self.velocity_i.append(random.uniform(-1, 1))
            self.position_i.append(x0[i])

    # evaluate current fitness
    def evaluate(self, costFunc):
        self.err_i = costFunc(self.position_i)

        # check to see if the current position is an individual best
        if self.err_i<self.err_best_i or self.err_best_i==-1:
            self.pos_best_i = self.position_i
            self.err_best_i = self.err_i

    # update new particle velocity
    def update_velocity(self, pos_best_g):
        # ---------- Attention: Probably Needs Fine Tuning ---------- #
        w = 0.5       # constant inertia weight
        c1 = 1        # cognative constant
        c2 = 2        # social constant
        # ---------- Attention: Probably Needs Fine Tuning ---------- #

        for i in range(num_dimensions):
            r1 = random.random()
            r2 = random.random()

            vel_cognitive = c1*r1*(self.pos_best_i[i] - self.position_i[i])
            vel_social = c2*r2*(pos_best_g[i] - self.position_i[i])
            self.velocity_i[i] = w*self.velocity_i[i] + vel_cognitive + vel_social

    # update the particle position based off new velocity updates
    def update_position(self, bounds):
        for i in range(num_dimensions):
            self.position_i[i] = self.position_i[i] + self.velocity_i[i]

            # adjust maximum position if necessary
            if self.position_i[i] > bounds[i][1]:
                self.position_i[i] = bounds[i][1]

            # adjust minimum position if neseccary
            if self.position_i[i] < bounds[i][0]:
                self.position_i[i] = bounds[i][0]


class PSO:
    def __init__(self, costFunc, x0, bounds, num_particles, maxiter):
        global num_dimensions

        num_dimensions = len(x0)
        err_best_g = -1                   # best error for group
        pos_best_g = []                   # best position for group

        # establish the swarm
        swarm = []
        for i in range(num_particles):
            swarm.append(Particle(x0))

        # begin optimization loop
        for i in range(maxiter):
            print(i, err_best_g)
            # cycle through particles in swarm and evaluate fitness
            for j in range(num_particles):
                swarm[j].evaluate(costFunc)

                # determine if current particle is the best (globally)
                if swarm[j].err_i<err_best_g or err_best_g==-1:
                    pos_best_g = list(swarm[j].position_i)
                    err_best_g = float(swarm[j].err_i)

            # cycle through swarm and update velocities and position
            for j in range(num_particles):
                swarm[j].update_velocity(pos_best_g)
                swarm[j].update_position(bounds)

        # print final results
        print('FINAL')
        print(pos_best_g)
        print(err_best_g)

"""## Validation"""

# Definition of test optimization problems for validation

def func1(x):
    total=0
    for i in range(len(x)):
        total+=x[i]**2
    return total

def func2(x):
    return x[0]**3

# Importing pre-built optimziers for validation
from scipy.optimize import dual_annealing

# Running result of optimizers

#--- Choose optimization problem ----------------------------------------------+
"""
func = F
initials = [80, 90, 80, 40, 10]
bounds = [[c, 200], [c, 200], [c, 200], [50, 200], [mu_2, 20]]
"""

# """
func = func1
initials = [34, 30]
bounds = [[-200, 200], [-200, 200]]
# """

"""
func = func2
initials = [34]
bounds = [[-200, 200]]
"""


#--- Result printing ----------------------------------------------------------+
print(f'Choosen problem: {func}\n')

print('---------- Start of scipy.dual_annealing ----------')
print(dual_annealing(func, bounds))
print('---------- End of scipy.dual_annealing ----------\n')

print('---------- Start of myPSO ----------')
PSO(func, initials, bounds, num_particles=15, maxiter=30)
print('---------- End of myPSO ----------')

"""# Verification on formulas

import sympy as sp
sp.init_printing(use_unicode=False, wrap_line=False)


# Constants
e = sp.Symbol('e')

a_1 = sp.Symbol('a_1')
a_2 = sp.Symbol('a_2')
b_1 = sp.Symbol('b_1')
b_2 = sp.Symbol('b_2')
D_0 = sp.Symbol('D_0')
beta_1 = sp.Symbol('beta_1')
beta_2 = sp.Symbol('beta_2')
beta_3 = sp.Symbol('beta_3')
c = sp.Symbol('c')
K = sp.Symbol('K')
alpha_1 = sp.Symbol('alpha_1')
alpha_2 = sp.Symbol('alpha_2')
alpha_3 = sp.Symbol('alpha_3')
gamma_1 = sp.Symbol('gamma_1')
gamma_2 = sp.Symbol('gamma_2')
gamma_3 = sp.Symbol('gamma_3')
delta_1 = sp.Symbol('delta_1')
delta_2 = sp.Symbol('delta_2')
delta_3 = sp.Symbol('delta_3')
mu_1 = sp.Symbol('mu_1')
mu_2 = sp.Symbol('mu_2')
theta_0 = sp.Symbol('theta_0')
theta_1 = sp.Symbol('theta_1')
xi = sp.Symbol('xi')
theta = sp.Symbol('theta')
S_0 = sp.Symbol('S_0')
h = sp.Symbol('h')
c_d = sp.Symbol('c_d')

# Control variables - [Verified]
lambda_1 = sp.Symbol('lambda_1')
s_1 = sp.Symbol('s_1')
s_2 = sp.Symbol('s_2')
s_3 = sp.Symbol('s_3')

# Omegas - [Verified]
omega_1 = sp.Symbol('omega_1')
omega_2 = sp.Symbol('omega_2')
omega_9 = sp.Symbol('omega_9')
omega_10 = sp.Symbol('omega_10')

# Omegas - [Unverified]
omega_3 = sp.Symbol('omega_3')
omega_4 = sp.Symbol('omega_4')
omega_5 = sp.Symbol('omega_5')
omega_6 = sp.Symbol('omega_6')
omega_7 = sp.Symbol('omega_7')
omega_8 = sp.Symbol('omega_8')
omega_11 = sp.Symbol('omega_11')
omega_12 = sp.Symbol('omega_12')
omega_13 = sp.Symbol('omega_13')

I = sp.Symbol('I')
# S = sp.Symbol('S')
p_1 = sp.Symbol('p_1')
p_2 = sp.Symbol('p_2')
p_3 = sp.Symbol('p_3')
u = sp.Symbol('u')
T = sp.Symbol('T')

t = sp.Symbol('t')


# sp.integrate(gamma_3*(p_3 + omega_1)*((1 - e**(delta_3*(mu_2 - t)))/delta_3 - e**(-delta_3*T)*omega_10)/(2*alpha_3*delta_3) + gamma_3*omega_1*((e**(theta*t) - e**((theta + delta_3)*mu_2 - delta_3*t))/(theta + delta_3) - e**((theta - delta_3)*T)*omega_10)/(2*alpha_3*(theta - delta_3)) + S*e**(-delta_3*(t - mu_2)), t)
"""

# I_mu_2 = sp.Symbol('I(mu_2)')
"""
S_mu_2 = sp.Symbol('S(mu_2)')
def S(t):
    first_term = gamma_3*(p_3 + omega_1)*((1 - e**(delta_3*(mu_2 - t)))/delta_3 - e**(-delta_3*T)*(e**(delta_3*t) - e**(2*delta_3*mu_2 - delta_3*t))/(2*delta_3))/(2*alpha_3*delta_3)
    second_term = gamma_3*omega_1*((e**(theta*t) - e**((theta + delta_3)*mu_2 - delta_3*t))/(theta + delta_3) - e**((theta - delta_3)*T)*(e**(delta_3*t) - e**(2*delta_3*mu_2 - delta_3*t))/(2*delta_3))/(2*alpha_3*(theta - delta_3))
    third_term = 0
    fourth_term = S_mu_2*e**(-delta_3*(t - mu_2))
    return first_term + second_term + third_term + fourth_term
"""
"""
def lambda_1(t):
    first_term = gamma_3*(p_3 + (h + theta*c_d)/theta)*((1 - e**(-delta_3*(T - t)))/delta_3)
    second_term = gamma_3*(h + theta*c_d)*e**(theta*t)/(theta*(theta - delta_3))*(1 - e**((theta - delta_3)*(T - t)))
    return first_term + second_term

omega_7 = lambda t: (e**(-delta_3*t) - e**((theta - delta_3)*mu_2 - theta*t))/(theta - delta_3)
omega_8 = lambda t: (e**(delta_3*t) - e**((theta + delta_3)*mu_2 - theta*t))/(theta + delta_3)
omega_13 = lambda t: omega_8(t) - e**(2*delta_3*mu_2)*omega_7(t)

def I(t):
    first_term = I_mu_2*e**(-theta*(t - mu_2))
    second_term = beta_3*p_3*(1 - e**(-theta*(t - mu_2)))/theta
    third_term = -a_2*(e**(-b_2*t) - e**((theta - b_2)*mu_2 - theta*t))/(theta - b_2)
    fourth_term = -gamma_3*S(mu_2)*e**(delta_3*mu_2)*omega_7(t)
    fifth_term_1 = gamma_3*(p_3 + omega_1)/delta_3*((1 - e**(theta*(mu_2 - t)))/(theta*delta_3) - (e**(delta_3*mu_2)*omega_7(t))/delta_3 - (e**(-delta_3*T)*omega_13(t))/(2*delta_3))
    fifth_term_2 = gamma_3*omega_1/(theta - delta_3)*((e**(theta*t) - e**(2*theta*mu_2 - theta*t))/(2*theta*(theta + delta_3)) - (e**((theta + delta_3)*mu_2)*omega_7(t))/(theta + delta_3) - (e**((theta - delta_3)*T)*omega_13(t))/(2*delta_3))
    fifth_term_3 = lambda_1(T)*e**(-delta_3*T)*omega_13(t)/(2*delta_3)
    fifth_term = -gamma_3/(2*alpha_3)*(fifth_term_1 + fifth_term_2 + fifth_term_3)
    return first_term + second_term + third_term + fourth_term + fifth_term

sp.simplify(sp.diff(I(t), t))
"""

"""
t = sp.Symbol('t')
I = sp.Function('I')(t)
S = sp.Function('S')(t)
I_ = sp.Derivative(I, t)
eq = sp.Eq(I_, -a_2*e**(-b_2*t) + beta_2*p_2 - gamma_3*S - theta*I)
# sp.solvers.ode.dsolve(eq, I, simplify=False)
# sp.simplify(sp.solvers.ode.dsolve(eq, I))
sp.solvers.ode.dsolve(eq, I)
"""

# sp.simplify(sp.solvers.ode.dsolve(eq, I))

# omega_1 = lambda u: (h + theta(u)*c_d)/theta(u)
#omega_2 = lambda t: (e**(delta_1*t) - e**(-delta_1*t))/(2*delta_1)
#omega_9 = lambda t: (e**(delta_2*t) - e**(2*delta_2*mu_1 - delta_2*t))/(2*delta_2)
#omega_10 = lambda t: (e**(delta_3*t) - e**(2*delta_3*mu_2 - delta_3*t))/(2*delta_3)


"""
def S(t):
    first_term = gamma_3*(p_3 + omega_1)*((1 - e**(delta_3*(mu_2 - t)))/delta_3 - e**(-delta_3*T)*(e**(delta_3*t) - e**(2*delta_3*mu_2 - delta_3*t))/(2*delta_3))/(2*alpha_3*delta_3)
    second_term = gamma_3*omega_1*((e**(theta*t) - e**((theta + delta_3)*mu_2 - delta_3*t))/(theta + delta_3) - e**((theta - delta_3)*T)*(e**(delta_3*t) - e**(2*delta_3*mu_2 - delta_3*t))/(2*delta_3))/(2*alpha_3*(theta - delta_3))
    third_term = 0
    fourth_term = S_mu_2*e**(-delta_3*(t - mu_2))
    # return first_term + second_term + third_term + fourth_term
    return fourth_term

sp.simplify(sp.integrate(S(t)*e**(t*theta), t))
"""